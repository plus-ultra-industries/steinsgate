name: Steins Task Sync (from Architect Artifact)

on:
  workflow_run:
    workflows: ["Steins Bootstrap"]
    types: [completed]
  workflow_dispatch:
    inputs:
      epic_number:
        description: "Epic issue number"
        required: true

permissions:
  contents: read
  issues: write

jobs:
  sync:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Create/update task issues from architect JSON block
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const inputEpic = '${{ github.event.inputs.epic_number }}';
            let epic = inputEpic ? Number(inputEpic) : null;
            let path = epic ? `darkfactory/artifacts/epic-${epic}/architect.md` : null;
            if (!path || !fs.existsSync(path)) {
              const base = 'darkfactory/artifacts';
              const candidates = fs.existsSync(base)
                ? fs.readdirSync(base)
                    .filter(d => d.startsWith('epic-'))
                    .map(d => ({ d, m: fs.statSync(`${base}/${d}`).mtimeMs }))
                    .sort((a, b) => b.m - a.m)
                : [];
              if (!candidates.length) throw new Error('No epic artifacts found. Run Steins Bootstrap first.');
              const latest = candidates[0].d;
              epic = Number(latest.replace('epic-', ''));
              path = `${base}/${latest}/architect.md`;
            }
            const md = fs.readFileSync(path, 'utf8');
            const m = md.match(/```json\n([\s\S]*?)\n```/);
            if (!m) throw new Error('No JSON block found in architect.md');
            const graph = JSON.parse(m[1]);

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            for (const task of graph.tasks || []) {
              const marker = `DarkForge-Task-ID: ${task.id}`;
              const title = `[TASK] ${task.title}`;
              const body = [
                `Parent Epic: #${epic}`,
                marker,
                `Owner Role: ${task.owner_role || 'engineer'}`,
                `Depends-On: ${(task.depends_on || []).join(', ') || 'none'}`,
                '',
                '## Acceptance Criteria',
                ...((task.acceptance || []).map(a => `- ${a}`))
              ].join('\n');

              const issues = await github.paginate(github.rest.issues.listForRepo, { owner, repo, state: 'open', per_page: 100 });
              const existing = issues.find(i => !i.pull_request && (i.body || '').includes(marker));
              const labels = ['df:task', (task.depends_on || []).length ? 'df:blocked' : 'df:ready'];
              if (existing) {
                await github.rest.issues.update({ owner, repo, issue_number: existing.number, title, body });
                await github.rest.issues.setLabels({ owner, repo, issue_number: existing.number, labels });
              } else {
                await github.rest.issues.create({ owner, repo, title, body, labels });
              }
            }
